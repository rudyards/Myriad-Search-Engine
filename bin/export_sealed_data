#!/usr/bin/env ruby

require_relative "../search-engine/lib/card_database"
require "memoist"

class ExportSealedData
  include Memoist

  def initialize(output_folder)
    @db = CardDatabase.load
    @factory = PackFactory.new(@db)
    @output_folder = Pathname(output_folder)
    load_uuids
  end

  def uuid_file_path
    Pathname(__dir__) + "../index/uuids.txt"
  end

  def load_uuids
    @uuids = {}
    uuid_file_path.each_line do |line|
      s, n, u, _ = line.chomp.split("\t")
      @uuids[s] ||= {}
      raise if @uuids[s][n]
      @uuids[s][n] = u
    end
  end

  def flatten_pack(pack)
    if pack.is_a?(WeightedPack)
      pack.flatten_weighted_pack
    else
      WeightedPack.new(pack => 1)
    end
  end

  def extract_sheets(pack)
    sheets = pack.packs.keys.map(&:sheets).flat_map(&:keys)
    sheets.map{|s| [s, @factory.sheet_cache.invert[s].join("_")] }.to_h
  end

  def serialize_subpack(pack, weight, sheets)
    {
      sheets: pack.sheets.map{|s,c| [sheets[s], c]}.to_h,
      weight: weight,
    }
  end

  def uuid_for(set_code, number)
    @uuids.fetch(set_code).fetch(number)
  end

  def serialize_sheet(sheet, extended)
    ev = sheet.probabilities
    # Normalize rationals to weights
    lcm = ev.values.map(&:denominator).inject(&:lcm)
    ev = ev.map{|k,v| vv = v*lcm; raise unless vv.to_i == vv; [k, vv.to_i] }.to_h

    if extended
      cards = ev.sort_by{|e,w| [e.set_code, e.number, e.foil ? 0 : 1]}.map do |e,w|
        name = "#{e.set_code}:#{e.number}"
        name = "#{name}:foil" if e.foil
        {
          set: e.set_code,
          number: e.number,
          weight: w,
          foil: e.foil,
          uuid: uuid_for(e.set_code, e.number)
        }
      end.sort_by{|x| [x[:set_code], x[:number].to_i, x[:number]] }
      total_weight = cards.map{|x| x[:weight]}.sum
    else
      cards = ev.sort_by{|e,w| [e.set_code, e.number, e.foil ? 0 : 1]}.map do |e,w|
        name = "#{e.set_code}:#{e.number}"
        name = "#{name}:foil" if e.foil
        [name, w]
      end.sort.to_h
      total_weight = cards.values.sum
    end

    {
      partner: sheet.is_a?(PartnerCardSheet) ? true : nil,
      balance_colors: sheet.is_a?(ColorBalancedCardSheet) ? true : nil,
      total_weight: total_weight,
      cards: cards,
    }.compact
  end

  def serialize_sheets(sheets, extended)
    sheets.map{|sheet, id|
      [id, serialize_sheet(sheet, extended)]
    }.to_h
  end

  def basic_output_path
    @output_folder + "sealed_basic_data.json"
  end

  def extended_output_path
    @output_folder + "sealed_extended_data.json"
  end

  def basic_data
    result = []
    @db.sets_with_packs.each do |set|
      pack = @factory.for(set.code)
      pack = flatten_pack(pack)
      sheets = extract_sheets(pack)
      result << {
        name: set.name,
        code: set.code,
        boosters: pack.packs.map{|subpack, weight| serialize_subpack(subpack, weight, sheets) },
        sheets: serialize_sheets(sheets, false),
      }
    end
    result
  end

  def extended_data
    result = []
    @db.sets_with_packs.each do |set|
      pack = @factory.for(set.code)
      pack = flatten_pack(pack)
      sheets = extract_sheets(pack)
      result << {
        name: set.name,
        code: set.code,
        boosters: pack.packs.map{|subpack, weight| serialize_subpack(subpack, weight, sheets) },
        sheets: serialize_sheets(sheets, true),
      }
    end
    result
  end

  def call
    basic_output_path.write JSON.pretty_generate(basic_data)
    extended_output_path.write JSON.pretty_generate(extended_data)
  end
end

output_folder = ARGV[0] || "."
ExportSealedData.new(output_folder).call
